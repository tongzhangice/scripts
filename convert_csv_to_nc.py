#!/usr/bin/env python

import numpy as np
from netCDF4 import Dataset
import subprocess
from optparse import OptionParser

parser = OptionParser(epilog='Convert csv data generated by Paraview to MPAS nc variable! The converted variable is saved in the new.nc')
parser.add_option("-n", "--nc_input", dest="nc_input", help="A nc file that includes basic geometry info.")
parser.add_option("-c", "--csv_input", dest="csv_input", help="The csv file we get from Paraview.")
parser.add_option("-v", "--var_name", dest="var_name", help="The variable name we want convert. Default the variable is a vector. For example, if we want to convert surface gradient, the csv file will contain all three fields, grad_x, grad_y and grad_norm, we can set -v surfGrad and the script will add x and y for us. The normal data can then be easily calculated after facts.")

for option in parser.option_list:
    if option.default != ("NO", "DEFAULT"):
        option.help += (" " if option.help else "") + "[default: %default]"
options, args = parser.parse_args()

var_x = options.var_name+'_x'
var_y = options.var_name+'_y'

subprocess.call(["cp",options.input_file,"new.nc"])
subprocess.call(["ncks","-v","thickness","new.nc", "tmp1.nc"])
subprocess.call(["ncks","-v","thickness","new.nc", "tmp2.nc"])
subprocess.call(["ncrename","-v","thickness,"+var_x,"tmp1.nc"])
subprocess.call(["ncrename","-v","thickness,"+var_y,"tmp2.nc"])
subprocess.call(["ncks","-A","-v",var_x,"tmp1.nc","new.nc"])
subprocess.call(["ncks","-A","-v",var_y,"tmp2.nc","new.nc"])

data_nc = Dataset("new.nc",'r+')
nCells = len(data_nc.dimensions['nCells'])
xcoord_nc = data_nc.variables['xCell'][:]
ycoord_nc = data_nc.variables['yCell'][:]

var_x_nc = np.zeros(nCells)
var_y_nc = np.zeros(nCells)

data_csv = np.loadtxt(options.csv_input, delimiter=',', skiprows=2)
var_x_csv = data_csv[:,-6]
var_y_csv = data_csv[:,-5]
# Here is an example for a vector data. Change the code if we want to convert a scalar data.

xcoord_csv = data_csv[:,-3]
ycoord_csv = data_csv[:,-2]
# normally the variable we save from Paraview is put to the -6 and -5 columns in the csv, and the coordination data are in the last 3 columns. But we should double check anyway.

index = 0

for i in range(nCells):

    x_csv = xcoord_csv[i]
    y_csv = ycoord_csv[i]

    index_x = np.where(abs(xcoord_nc-x_csv)<1)[0]
    index_y = np.where(abs(ycoord_nc-y_csv)<1)[0]
# if the coordination difference < 1, then we find one of those identical cells. It's ok with ice sheet geometry in general, but if we want to use some microscopic geometry, change 1 here to some small numbers as you like
    index_xy = np.intersect1d(index_x,index_y)

    if (np.size(index_xy)==1):
        index = index + 1

    var_x_nc[index_xy] = var_x_csv[i]
    var_y_nc[index_xy] = var_y_csv[i]


print ("{0:8d} data converted".format(index))

data_nc.variables[var_x][0,:] = var_x_nc
data_nc.variables[var_y][0,:] = var_y_nc

data_nc.close()

